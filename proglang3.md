## Функции и процедуры

Написав уже первые несколько программ, люди стали думать над тем, как этот процесс упростить.
Исторически первым способом использования уже написанного кода стала организация подпрограмм
или, иначе, процедур. В языке Fortran уже есть возможность описывать процедуры и функции.
Быстро выяснилось, что кроме первоначального назначения их как способа не писать один и
тот же код дважды, подпрограммы служат мощным средством структурирования программы и
организации процесса программирования.

Действительно, можно легко разделить большую программу на части, если только описать,
как именно будут взаимодействовать между собой процедуры. Можно даже поручить написание
процедур разным людям. Поэтому самой сложной частью аппарата функций и процедур в языках
программирования всегда была передача параметров и организация общих переменных.
Те параметры, что написаны в тексте процедуры, называются формальными, а те, которые
пишутся в вызывающей программе - фактическими. При вызове процедуры или функции
формальным параметрам ставятся в соответствие фактические.

Вызов процедуры чем-то похож на оператор GOTO, только при вызове процедуры каким-то
образом запоминается место, откуда она была вызвана, а по окончании выполнения происходит
возврат (то есть еще один GOTO) на запомненное место вызова. Другая интерпретация
семантики вызова процедуры состоит в том, чтобы просто скопировать ее код в место
вызова и подставить вместо формальных параметров фактические.

Некая терминологическая проблема состоит в том, что в разных языках процедуры и
функции называются разными словами. В C все они называются функциями, в Algol,
наоборот, процедурами, в Fortran используется слово «подпрограмма» (subroutine) итп.
Не обращая особого внимания на принятую терминологию, мы рассмотрим два концептуальных
класса объектов, которые будем называть «процедуры» и «функции», хотя последовательно
разница между ними проводится в очень немногих языках, среди которых можно назвать Ada.
Разница состоит не в написании, а в назначении: функции предназначены только для того,
чтобы вычислять значение, а процедуры чтобы сделать что-то полезное. Все вместе процедуры
и функции будем называть подпрограммами, имея в виду, что их основная цель - как-то
обособить участок программы.

### Макроподстановки

Программист должен быть ленив, это заставляет его больше думать и меньше делать
и в итоге приводит к более качественному коду. Разумеется, никто не хочет писать
один и тот же кусок программы несколько раз. Первый способ, который находит для
себя начинающий программист, называется «китайский метод повторного использования
кода copy/paste» - простое копирование кусков программы. Но даже этот способ ленивые
программисты сумели автоматизировать. Макроподстановка или просто макро позволяет
выделить какой-то текст, дать ему имя и далее копировать сколько угодно, причем
средствами языка а не текстового редактора. При правильном использовании это дает
более читаемый текст.

~~~c
#include <stdio.h>
#define sayit printf(“I will always use Google before asking dumb questions\n”)

main()
{
  sayit;
  sayit;
  sayit;
}
~~~

В макроопределения можно вводить параметры, и они будут подставлены в текст программы,
обычно без какой-либо проверки. Макроподстановка - опасный инструмент, с его помощью можно
легко запутать любую программу.

~~~c
#define int float
#define float int
...
~~~

Исторически макроподстановки впервые появились в ассемблере, поскольку этот язык
больше других располагает к созданию длинных  текстов, состоящих их повторяющихся
(почти) одинаковых фрагментов.

Но это еще не все. Некоторые языки программирования используют макроопределения
и макроподстановки в качестве основного инструмента и главной идеи, на которой
строится весь язык. Из этих языков наиболее известен **TRAC**.

Более последовательно идея макроподстановок проводится в более современных языках,
например, в **nim**. Там для простых условных макроподстановок используется оператор
`when`, почти идентичный оператору `if`:

~~~nim
when system.hostOS == "windows":
  echo "running on Windows!"
elif system.hostOS == "linux":
  echo "running on Linux!"
elif system.hostOS == "macosx":
  echo "running on Mac OS X!"
else:
  echo "unknown operating system"
~~~

Отличие только в том, что соответствующая строка будет не выполнена, а скомпилирована, и
проверок во время выполнения произведено не будет. Если константа system.hostOS окажется равна
"linux", то весь приведенный фрагмент будет в точности эквивалентен такому:

~~~nim
  echo "running on Linux!"
~~~

### Передача  параметров

Передать параметры в процедуру или функцию можно многими разными способами. Единственным
в своем роде исключением тут можно считать некоторые ранние диалекты языка Basic,
в которых передачи параметров в процедуры нет вообще. Хотите передать значение -
кладите его в переменную. Во всех остальных распространенных языках используются
следующие способы передачи параметров:

#### Передача значений

Процедуре передаются копии значений параметров. Соответственно, изменить какие-то переменные вызывающей программы процедура не может.

~~~pascal
procedure test(x:integer);
begin
  writeln(x);
  x:=x+1;
  writeln(x);
end;

var  xx:integer;
begin
  xx:=1;
  test(xx);  (* xx не изменяется после выполнения процедуры *)
  writeln(xx);
end.
~~~

Заметим, что в языке C этот способ является единственным.

#### Передача ссылок

~~~pascal
procedure test(var x:integer);
begin
  x:=x+1;
end;

var  xx:integer;
begin
  x := 3;
  test(xx);  (* xx после выполнения процедуры увеличится на 1 *)
end.
~~~

Отличие состоит в том, что в процедуру передается ссылка на переменную, и переменная
x в процедуре и xx в вызывающей программе относятся к одной и той же области памяти. Этот способ
передачи параметров является единственно возможным в языке Fortran. Возникает естественный
вопрос: Что, если в качестве параметра будет передано выражение? Константа? Можно выражения
в качестве параметров-ссылок вообще запретить. Так и сделано в языке Pascal. Но что делать,
если других способов передачи параметров вообще нет в языке? Разработчики Fortran нашли
весьма своеобразное решение этой проблемы. Если в качестве параметра указана переменная,
то процедуре передается ссылка на эту переменную. А если там выражение, то создается специальная
безымянная переменная, ссылка на которую передается процедуре. Все изменения этой переменной,
произведенные процедурой, теряются. С константой все интереснее. Некоторые компиляторы Fortran
не создавали копию константы, а передавали ссылку на место хранения самой константы, в надежде,
что программист знает, что делает и не будет менять значение в процедуре. Таким образом
Fortran давал возможность изменить значение константы. Что, разумеется, приводило к
непредсказуемым последствиям.

#### Передача по имени.

Рассмотренные два способа передачи параметров являются основными. Но был еще один
странный способ в языке Algol, который интересно рассмотреть. Он заключался в том,
что переданное в процедуру выражение вычислялось каждый раз так, как если бы вместо
формальных параметров были подставлены их значения,  вычисленные в контексте вызывающей
программы. По сути это нечто среднее между макроподстановкой и вызовом подпрограммы.
Разобраться с этим способом нам поможет пример, называемый «прием Йенсена» по имени изобретателя.

~~~algol
begin

  procedure p (a, b);
    name a, b; integer a, b;
  begin
    for a:=1 step 1 until 10 do
      b := 0
  end p;

  integer i; integer array s [1:10];
  p (i, s[i])
end
~~~

При выполнении процедуры p на каждом шаге цикла вместо a подставляется i, а вместо
b подставляется s[i], и эта процедура просто обнуляет массив s. Проблем с таким способом передачи
параметров очень много, а из преимуществ можно назвать только прием Йенсена. Поэтому
передача параметров по имени так и осталась курьезом из языка Algol.

Передача параметров по имени это нечто среднее между макроподстановкой и передачей
функций как параметров. В современных языках программирования обычно используют
передачу функций для достижения тех же целей. Вот реализация приема Йенсена на Javascript

~~~javascript
  function p (f){
    var i;
    for (i=0; i<10; ++i)
      f(i,0)
   }

  s = Array(10);
  p( function(i,v){ s[i] = v;} );
~~~

#### Передача невычисленных выражений

(отложенное, или ленивое вычисление).

Рассмотрим пример на языке С

~~~c
void f1(int a)
{
   if (a) printf("yes");
}

void f2(int a, int b)
{
   if (a || b) printf("yes");
}


main()
{
  int x = 1, y=2, z=0;
  f1((x==1) || (y/z == 1)); // работает
  f2((x==1),(y/z == 1));    // не работает, возникает деление на 0
}
~~~

Происходит это потому, что если в выражении ```(x==1) || (y/z == 1)``` первое условие
выполнено, то дальше считать не имеет смысла, на результат это не повлияет. Но сделать
то же самое внутри процедуры мы не можем, потому что значения параметров должны
быть вычислены до вызова процедуры. Заметим, что в случае передачи параметров
по имени оба способа будут работать.

В некоторых языках программирования существует еще один способ передачи параметров,
который называется отложенными или «ленивыми» (lazy) вычислениями. Он похож на
передачу параметра по имени, и отличается тем, что  вычисление выражения происходит
один раз, но только тогда, когда это значение действительно понадобится. В таких
языках оба примера будут работать, если только параметры процедур объявлены как
«ленивые».

### Функции

Теперь поговорим о функциях. Цель функции — получить значение, в отличие от процедуры, цель
которой — произвести какое-то действие. Если функция все-таки изменяет среду исполнения, например,
выводит какое-то число на дисплей, это называется «побочным эффектом». К проблеме побочных эффектов
в императивных языках есть два диаметрально противоположных подхода. В языке Ada побочные эффекты
функций просто запрещены. Смысл в этом есть, ведь в выражении, подобном  `(x==1) || f(y)` , функция
`f(y)` может так и остаться никогда не вычисленной. Если она производит какое-то действие кроме вычисления
значения, это действие так и не произойдет. Это может привести к довольно сложно обнаруживаемым ошибкам.
С другой стороны, в языке C вообще нет разницы между функциями и процедурами. В C и процедуры и функции
формально считаются функциями, причем процедуры возвращают специальное значение, принадлежащее к типу
void, которое символизирует отсутствие результата. А тот факт, что в вышеприведенном выражении
функция f(y) при x равном 1 не будет вычислена, считается дополнительным удобством для программиста.
Наследники языка C идут в этом отношении еще дальше. Стандартный способ аварийного прекращения программы
в языках PHP и PERL такой:

~~~php
($x == 1) or die (“X не равен 1, аварийное завершение программы“)
~~~

Функция die выводит сообщение и завершает выполнение программы. Формально это выражение, состоящее из
логического условия и вызова функции. Куда при этом девается результат? Как и в языке C - выбрасывается
за ненадобностью.

#### Рекурсия

В математике часто используется определение функций через самих себя, рекуррентно. Например, факториал числа
можно определить так:

  N! это 1 если N=1
  и N * (N-1)! в противном случае.

Запишем это определение на языке Python

~~~python
def fact(N):
  if N == 1:
    return 1
  else:
    return N * fact(N-1)

print(fact(6))
~~~

В некоторых ранних языках программирования рекурсия была невозможна или затруднена. Обсуждалось даже
использование специального ключевого слова recursive в определении функции для того, чтобы сообщитько
компилятору, что функция будет вызывать саму себя. Д. Баррон в своей книге резонно заметил, что лучше
было бы помечать некоторые функции как не-рекурсивные, поскольку в этом случае компилятор сможет
сгенерировать более оптимальный код. В наши дни проблем с вызовом рекурсивных функций вроде бы нет, все
функции могут вызывать сами себя.

Однако, некоторые проблемы остаются. Например, в функциональном языке Ocaml при определении рекурсивных
функций следует использовать специальное ключевое слово rec. Зачем? Затем, что в OCaml определение функции это
просто присваивание, и в момент обработки его правой части компилятор еще "не знает" имени функции, то есть имени той
переменной, которой будет присвоена определяемая функция.

~~~ocaml
let rec fact n =
    if n == 1 then 1 else n * fact (n-1);;
~~~

Слово **rec** неким магическим способом решает эту проблему.

Очевидным недостатком прямого рекурсивного определения функций является необходимость хранить промежуточные
результаты вычислений, причем иногда их бывает много. При вычислении `fact(6)` по приведенному выше алгоритму
будут последовательно запомнены числа 6,5,4,3,2. И только после получения от вызова fact(1) значения 1 все они
будут перемножены. Для решения этой проблемы в некоторых языках программирования, как правило, функциональных,
применяется так называемое *устранение хвостовой рекурсии*. С формальной точки зрения рекурсивное определение
функции состоит из двух частей, базы и шага. Базовая часть это обычно константа, а шаг представляет собой
приближение к базовой части. В случае факториала база это fact(1), равный 1, а шаг это вычисление fact(n) через
fact(n-1).

Если рекурсивный вызов в шаге рекурсии является в точности повторением вызова самой функции, то есть при этом не запоминается
никаких промежуточных значений, то процесс рекурсивного вычисления функции становится намного проще. Покажем это на примере

~~~python
def fact(N):

  def fact1(N,A):
    if N == 1:
      return A
    else:
      return fact1(N-1,A*N)

  return fact1(N,1)

print(fact(6))
~~~

Здесь использована внутренняя функция, вычисляющая факториал числа, и внешняя "обертка" для нее. Идея состоит в том,
что мы говорим, что fact(6) это то же самое, что fact1(6,1), а это то же самое, что fact1(5,6) == fact1(4,30) ==
fact1(3,120) == fact1(2,360) == fact1(1,720) == 720. Определения базы и шага становятся менее ясными, но зато
компилятор может сгенерировать намного более быстрый код. Такое описание рекурсивной функции из двух частей является
стандартным приемом во многих функциональных языках, а если нам почему-то нужно написать программу, которая никогда
не завершается (бесконечный цикл), то устранение хвостовой рекурсии является обязательным.

База рекурсии не всегда состоит из одного случая, их может быть два и больше. Рассмотрим, например, рекурсивное
определение того, что такое палиндром (строка, которая читается одинаково от начала к концу и от конца к началу).

~~~python
def palindrom(N):
  if len(N) == 0:     # пустая строка является палиндромом
    return True
  if len(N) == 1:     # строка длиной в 1 символ тоже является палиндромом
    return True
  if N[:1] != N[-1:]: # если первый и последний символы не совпадают
    return False      # то это не палиндром
  return palindrom(N[1:-1])

print(palindrom("adda"))
print(palindrom("ada"))
print(palindrom("axddaa"))
~~~

Здесь два базовых случая, для строк длиной 1 символ и 2 символа.
Еще одна проблема с рекурсией состоит в формулировании базы. Посмотрим еще раз на функции, вычисляющие
факториал числа. Если любую из них вызвать с отрицательным N, программа зациклится. Поэтому для отрицательных чисел
нужно отдельно задавать базовый случай, который должен либо генерировать ошибку, либо возвращать какое-то специальноо
говоренное число (например, 0).

#### Запись результата функции

В разных языках существуют различные способы сообщить, какое именно значение должна вернуть функция.
Самый простой способ состоит в том, чтобы ввести специальный оператор возврата значения - return.

~~~c
int sqr(int x)
{
  return x*x;
}
~~~

Другой довольно распространенный способ состоит в том, чтобы положить требуемое значение в специальную
предопределенную переменную с именем, совпадающим с именем функции и имеющая тот тип, который функция должна вернуть.

~~~pascal
function sqr(x:integer):integer;
begin
  sqr:=x * x;
end;
~~~

С виду все просто, но на практике такая запись оказывается очень неудобной. Если программист решит
переименовать какую-то сложную функцию, то ему придется переименовывать и каждое вхождение
переменной-результата. Более серьезная проблема состоит в том, может ли эта переменная появляться справа
от знака присваивания? С одной стороны, это обычная переменная. С другой - в языке Pascal, где используется
именно этот метод, вызов функции без параметров ничем не отличается от обращения к переменной.

~~~pascal
var q:integer;

function interesting:integer;
begin
   interesting:=q;
   if interesting = 0 then
   begin
    q:=100;
    interesting := interesting+1;
   end;
   q := q - 1;
end;
~~~

Появляется неоднозначность: interesting в операторе if и справа от знака присваивания может означать либо
рекурсивный вызов этой же функции, либо переменную-результат. Заметим, что этот странный пример будет работать
в любом случае, хотя и будет возвращать разные числа.

В результате в языке Pascal появление переменной-результата в том контексте, где требуется значение,
запрещено. Несмотря на неудобство, этот способ по историческим причинам оказался широко распространен.
Со временем сложилась программистская практика, устраняющая основные недостатки переменных-результатов.
Она состоит в том, чтобы самому объявить еще одну вспомогательную переменную, вычислить результат и в конце
функции переложить его в  переменную-результат.

~~~pascal
function sqsum(a,b:integer):integer; // (a+b)^2
var res:integer;
begin
  res := a+b;
  res := res * res;
  hyp := res ;
end;
~~~

Метод оказался настолько удачным, что в языке Object Pascal (Delphi) ввели специальную автоматически
объявляемую переменную с именем result.

#### Глобальные переменные

Использование подпрограмм вызвало еще одну проблему. У каждой функции или процедуры могут быть локальные
переменные, которые, кроме нее самой, не доступны никому. Но очень часто нужно иметь доступ к каким-то
переменным из нескольких процедур, или же сохранять значение какой-то переменной между последовательными
вызовами функции. Самый распространенный пример - генератор последовательности чисел.

~~~pascal
var seed:integer;

function nextval:integer;
begin
   seed:=seed+1;
   nextval := seed;
end ;

procedure setseed;
begin
  seed:=0;
end ;
~~~

Обратите внимание, что в данном примере присутствуют два варианта использования глобальных переменных.
Функция **nextval** и процедура **setseed** обращаются к одной и той же глобальной переменной **seed**, а последовательные
вызовы **nextval** используют тот факт, что переменная **seed** является внешней по отношению к этой функции и сохраняет
присвоенное значение. Таким образом, один и тот же механизм глобальных переменных решает обе поставленные задачи.

Но так было не всегда. По какой-то непонятной причине разработчики языков **Fortran** и **Algol** считали,
что процедура или функция не должна «видеть» ничего, находящегося за ее пределами. Поэтому упомянутые
задачи решали по отдельности. В языке Algol было введено специальное ключевое слово own, означавшее,
что значение объявленной таким способом переменной сохраняется между вызовами подпрограммы. На **Algol**
функция nextval выглядела бы так:

~~~algol
real procedure nextval;
begin
   own integer seed;
   seed:=seed+1;
   nextval:=seed;
end;
~~~

Тут все вроде бы хорошо, но непонятно, как этому seed присвоить начальное значение.
В языке Fortran, наоборот, основные усилия сосредоточили на решении второй задачи, сделав специальное ключевое слово COMMON.

~~~fortran
      SUBROUTINE SETSEED
      INTEGER SEED
      COMMON /GLOBALSEED/ SEED
      SEED = 0
      END

      FUNCTION NEXTVAL()
      INTEGER NEXTVAL
      INTEGER SEED
      COMMON /GLOBALSEED/ SEED
      SEED = SEED+1
      NEXTVAL = SEED
      END
~~~

В отличие от Pascal и C, в Fortran каждая подпрограмма содержит свое собственное описание переменной SEED.
Если эти описания будут разными, результат окажется непредсказуемым. Такое странное решение было принято с
целью обеспечить возможность независимой компиляции подпрограмм.

#### Раздельная компиляция

Основная идея, лежащая в основе раздельной компиляции такова: сделать участки кода как можно более независимыми
друг от друга, компилировать каждый из них только один раз и хранить где-то полученный машинный код. Это позволяло
сэкономить время работы компилятора, которое было весьма дорогим на старых компьютерах. Если какая-то подпрограмма
работает правильно, нет необходимости компилировать ее каждый раз заново, достаточно знать, как ее вызвать. Такие
подпрограммы можно объединять в библиотеки, и вызывать по мере необходимости. На реализацию такой функциональности
обращали особое внимание при создании языка Fortran, и тогда же сформировались три главные проблемы раздельной компиляции:

1) Программист должен знать, как вызывать функцию.
2) Хотелось бы, чтобы компилятор имел возможность проверить, правильно ли функция была вызвана.
3) Что делать, если нужно изменить библиотечную функцию, а ее уже кто-то использует?

Надо сказать, что ранние языки не предоставляли вообще никаких средств для решения этих проблем.
Предполагалось, что для программиста будет написана некая инструкция, описывающая правильную работу с
библиотекой. А программист все сделает правильно и в соответствии с инструкцией. Даже в языке C есть возможность
вызвать любую подпрограмму сколь угодно неправильным способом. Например:

~~~c
/* #include <stdio.h> */
main()
{
  int x = printf(0.5);
}
~~~

Формально компилятор должен выдать предупреждение о том, что тут происходит нечто не совсем правильное.

Основная идея решения проблемы проверки правильности вызовов состоит в том, чтобы создать какой-то отдельный
файл с описаниями правил вызова библиотечных функций, но без их содержания. Компиляция этого файла тоже понадобится,
но займет намного меньше времени. В языке C для этого служат так называемые include-файлы. В языке **Modula-2** они
называются def-файлы. В **Turbo Pascal** файл с библиотечными подпрограммами делится на секции **interface** и **implementation**.
Иметь один файл с описаниями намного лучше, чем дублировать описания в каждой подпрограмме. Одновременно
получается документ, которым может пользоваться и программист. Разумеется, без комментариев такой файл имеет
ограниченную полезность, но за много лет стало совершенно ясно, что задача заставить программиста комментировать
код в процессе его написания находится где-то между «очень сложно» и «практически невозможно». Если в случае
**Fortran** от программиста требовался довольно пространный текст, то в случае **C** или **Pascal** отделить описание
функции, которое нужно компилятору для правильного ее вызова - дело простое, и комментарии требуются в
меньшем объёме. В более поздних языках, например, в **C++**, вызов функции, не имеющей описания, вообще невозможен
(что не мешает сделать неправильное описание).

Что касается третьей проблемы - несовместимости версий - то, несмотря на многочисленные попытки ее решить,
она существует и сегодня.

#### Запись вызова функций и подпрограмм

Вопрос о том, как именно синтаксически оформить вызов подпрограмм, на первый взгляд кажется малосущественным.
Однако, в языке Fortran использовалось специальное ключевое слово для вызова процедур.

  `CALL f(x)`

В дальнейшем от использования ключевого слова отказались, и стали писать просто

  `f(x);`

В записи же функций долгое время особого разнообразия не наблюдалось, поскольку запись была заимствована из
языка математики. Некоторое разнообразие наблюдалось только в отношении функций и процедур, не имеющих аргументов.
Вопрос стоял так: писать ли пустые скобки? В Pascal скобки писать не нужно, и это решение имеет два важных
последствия, одно хорошее и одно плохое. Во-первых, можно писать программы, похожие на текст на английском языке:

~~~pascal
begin
initialize_variables;
open_files;
perform_calculations;
write_results;
close_files;
end.
~~~

Про такие программы говорят, что они обладают свойством самодокументируемости. Про второе последствие мы
уже говорили: функция без параметров синтаксически неотличима от простой переменной.

#### Функции с переменным числом аргументов

Тенденция к переносу средств ввода-вывода из языка в библиотеки, о которой мы будем говорить позже,
привела к необходимости появления процедур с переменным числом аргументов (и функций тоже, но они нужны реже).
Одна из первых попыток была предпринята в языке Pascal. Там есть процедуры с переменным числом аргументов, но это
были «специальные» процедуры, по существу, операторы языка, лишь внешне напоминавшие обычные. Способа создать свою
процедуру  с переменным числом аргументов в классическом Pascal нет. Надо заметить, что на уровне машинных кодов
традиционно рассматривают два способа передачи параметров в процедуру или функцию: "паскальный" и "сишный". Все
современные компиляторы этих языков умеют использовать оба способа вызова, однако в каждом языке по умолчанию
используется "свой" способ вызова. При использовании "паскального" способа вызова подпрограммы реализация
функций с переменным числом параметров существенно затруднена.

В языке С  процедуры с переменным числом аргументов уже можно создавать, и имеется стандартный механизм, позволяющий
эти аргументы получать. Для этого нужно или иметь возможность определить число аргументов, анализируя первые несколько
переданных значений, или принять соглашение о том, что какое-то определенное значение будет являться признаком окончания
списка аргументов.

Таким образом, в C могут быть два вида вызовов процедуры с переменным числом аргументов:

  `f(n, a1, a2 ... an);`
и
  `f(a1, a2 ... an, NN);`

где NN - константа, которая не может встретиться среди значений аргументов, обычно это 0. Способа узнать, сколько
параметров было в действительности передано, в C не существует, и программист может легко создавать трудноуловимые
ошибки. Вот как выглядит описание функции с переменным числом аргументов:

~~~c
int add_them_all( int arg_count, ... )
{
    va_list ap;
    int sum = 0 ;
    va_start( ap, arg_count );
    for(; arg_count > 0; --arg_count )
      sum += va_arg( ap, int );
    va_end( ap ) ;
    return sum ;
}
~~~

Еще один способ сделать то же самое использован в языках **Python** и **Javascript**. Фактически переданные параметры
попадают в специальный массив, который в **Javascript** называется **arguments**, а в Python имя ему присваивает
программист.

~~~javascript
function sum()
{
   var s = 0;
   for(i=0; i<arguments.length; ++i)
      s = s+arguments[i];
   return s;
}

console.log(sum(1,2,3)); // напечатает 6
~~~

~~~python
def sum(*arg):
  sum = 0
  for i in arg:
    sum = sum+i
  return sum

print(sum(1,2,3,4)) # напечатает 10
~~~

Существует и другой способ организовать подпрограмму в переменным числом аргументов.
Для этого достаточно часть аргументов объявить необязательными. Самый, опять же, простой способ это сделать -
присвоить им начальные значения. Если считать, что формальные аргументы сопоставляются фактическим слева направо,
и необязательными объявлены один или несколько наиболее правых из них, то разночтений не возникает.

~~~c
int func(int x, int y=0, int z=0);

func(1,2) // x=1, y=2, z=0
func(5) // x=5, y=0, z=0
~~~

#### Объекты первого класса

В описанииях языков программирования часто встречается термин `first class citizens` или `first class objects`.
Это устоявшийся термин для обозначения того, как могут быть использованы те или иные сущности языка.
Сущности "первого класса" имеют право появляться в следующих контекстах:

1. Они могут быть параметрами функций и процедур
2. Они могут быть результатами функций
3. Их можно присваивать переменным

В ранних языках программирования функции и процедуры не относились в полной мере к первому классу, но
постепенно получали все больше "прав".

#### Ссылки на функции

Идея присвоить ссылку на функцию какой-нибудь переменной кажется вполне естественной. Функция, как и все, что
есть в памяти компьютера, имеет адрес, этот адрес никто не мешает запомнить в какой-то переменной. Но в
программах, написанных начинающими программистами, такие переменные встречаются на удивление редко.
Видимо, это происходит вследствие того, что синтаксически функции выглядят совершенно иначе, чем данные.
Поэтому вместо

~~~c
void map(double *x, int length, double (*fun)(double))
{
  int i;
  for(i=0;i<length;i++)
    x[i] = fun(x[i]);
}
~~~

часто пишут что-то вроде

~~~c
typedef enum { FN_SIN, FN_COS }  FUNCTION;
void mapnf(double *x, int length, FUNCTION f)
{
  int i;
  for(i=0;i<length;i++)
    switch(f)
    {
    case FN_SIN:
      x[i] = sin(x[i]); break;
    case FN_COS:
      x[i] = cos(x[i]); break;
    }
}
~~~

Недостатки второго способа очевидны: для добавления еще одной функции придется переписывать код. Тем не менее,
его разновидности встречаются чаще, чем хотелось бы.

#### Типы результата

Традиционно в школьной математике считается, что функция возвращает число. Однако, в других разделах
математики функция, в качестве результата имеющая матрицу или даже другую функцию, не являются чем-то
необычным. Такую возможность довольно быстро включили и в языки программирования. Единственной
сложностью, на первых порах замедлявшей введение подобных функций в языки, было опасение,
что это приведет к низкой эффективности программ. Действительно, передача большого массива
вызывает, как минимум, однократное копирование его содержимого. Тем не менее, идея оказалась
настолько привлекательной, что возможность возвращать в качестве результата что-то помимо чисел имеется
почти во всех современных языках программирования.

#### Типы функций и карринг

Допустим, у нас есть функция, возвращающая целое число, и имеющая один аргумент целого типа. Поскольку в языках
со строгой типизацией «все имеет какой-то тип», логично спросить, какой тип имеет сама функция? В классических
императивных языках вроде **C** или **Pascal** существуют типы для указателей на функции. Формально это обстоятельство
предполагает существование типов самих функций, но создать переменную типа «функция» в языке **C** или **Pascal** не
получится. В некоторых языках функция может сама по себе быть объектом «первого класса», в таких языках функции
имеют типы. И на примере этих языков  имеет смысл изучить типы, к которым принадлежат различные функции.
Возьмем  обозначения типов в языке **Haskell**:

Тип ```Integer->Float``` это вещественная функция целого аргумента. С точки зрения математики эта функция
является отображением множества целых чисел Integer на множество вещественных чисел Float. `Float->Float` это
функция, которая получает на входе  вещественное число  и возвращает вещественное число. Далее ```Float->Float->Float```
функция, которая получает на входе два вещественных числа и возвращает вещественное число. Но этот тип
можно интерпретировать и по-другому: функция, которая получает одно число типа
Float и возвращает функцию типа ```Float->Float```. Действительно, если у функции с двумя аргументами
зафиксировать один аргумент, то получится функция одного аргумента. Рассмотрим выражение

  `A + X`

Если несколько необычным способом поставить скобки, то получится функция «A плюс» от X, прибавляющая A к аргументу:

  `(A +) X`

Далее можно записать определение функции:

  `F = (A +)`

где мы просто обозначаем нашу функцию, прибавляющую A, как F. Такой прием называется карринг, и широко
используется в функциональных языках. Раз уж мы заговорили про функции как отдельные сущности, то попробуем
пойти чуть дальше, и поговорить про

### Лямбда

Идея, лежащая в основе одной из самых красивых концепций программирования, очень проста.

~~~python
import math

def my_function(x):
    return math.sin(math.cos(x))

def sum_fun(f,x_min,x_max,step):
    s = 0;
    x = x_min
    while x < x_max:
        s = s+f(x)
        x = x+step
    return s

print(sum_fun(my_function,0,1,0.1))
~~~

В этом примере функция с именем **my_function** нужна только для того, чтобы передать ее в другую
функцию, и имя ее нам совершенно не важно. Поэтому в языке **Python** есть возможность ее никак
не называть:

~~~python
import math

def sum_fun(f,x_min,x_max,step):
    s = 0;
    x = x_min
    while x < x_max:
        s = s+f(x)
        x = x+step
    return s

s = sum_fun( lambda x:math.sin(math.cos(x)), 0, 1, 0.1 )
print(s)
~~~

Заметим еще одну особенность такой записи: функция описывается там, где используется. Если в первом
варианте, увидев запись ```print(sum_fun(my_function,0,1,0.1))```, мы должны просмотреть код, чтобы
узнать, что же такое my_function, то во втором она сразу видна. Недостаток языка Python, видимо, неустранимый,
в том, что такая безымянная функция может состоять только из одного выражения.

В языке Javascript все проще:

~~~javascript
function sum_fun(f,x_min,x_max,step)
{
  var s = 0;
  var x = x_min;
  while (x < x_max)
  {
    s = s+f(x);
    x = x+step;
  }
  return s;
}

var s = sum_fun(
    function(x){ return Math.sin(Math.cos(x)); },0, 1, 0.1
);
console.log(s);
~~~

Полученную таким способом безымянную функцию можно передать как параметр, присвоить переменной или вернуть
в качестве значения другой функции. Фактически, конечно, при этом передается не сама функция (непонятно, что это такое),
а ссылка на нее. Особую роль лямбда-исчисление играет в функциональном программировании.

### Функции левой части

Исходя из соображений симметрии, часто хочется наряду с

    x := min(a,b);

писать

    min(a,b) := x;

Смысл этого вполне очевидный - переменной, которая имеет минимальное значение, присвоить значение x.
Ссылки в языке C++ дают нам такую возможность.

~~~c
int& min(int& x, int& y)
{
  if (x < y)
    return x;
  else
    return y;
}

...

min(a,b) = 5;
~~~

### Перегруженные (overloaded) подпрограммы

В математике мы сталкиваемся с тем фактом, что, например, корень квадратный из
натурального числа это не совсем то же самое, что корень квадратный из вещественного
числа, хотя записываются они совершенно одинаково.

В программировании тоже логично было бы вместо преобразования типов использовать
различные версии одних и тех же функций для различных типов аргументов.
В ранних языках программирования эта задача
решалась достаточно прямолинейно: придумывали разные имена для разных функций.
В языке Fortran дело даже дошло до неформального соглашения: к названию функции
приписывали букву, означающую используемый тип. Так, модуль вещественного числа
назывался ABS, целого числа IABS, комплексного числа CABS, итд.

Возложить на компилятор обязанность различать  функции по типам аргументов догадались не
сразу. Первые попытки состояли в том, что компилятор «заранее знал» про некоторые функции
и мог подставить нужный код. Такие подпрограммы получили название полиморфных, или перегруженных.
Программист не мог сам определить такую функцию. Разумеется, арифметические операции были
полиморфными изначально, и в языке Algol-68 программисты получили возможность определять
полиморфные операторы, но не функции. Причины, по которым введение полиморфных функций было
отложено до 1976 года (язык ML), остаются не вполне понятными.

В мир императивных языков полиморфные функции были введены в 1983 году с языком C++. Изобретатель
языка Бьерн Страуструп настолько боялся новой идеи, что постарался, как он сказал, «изолировать»
полиморфные функции.

~~~c
overload print (int x);
overload print (char *x);
overload print (int n, char *x);
~~~

Для этого использовалось ключевое слово overload, совершенно ненужное. Если программист
определил функцию print с аргументом типа int, то ее так и следует вызывать, независимо
от того, есть ли другие функции с тем же именем. И, наконец, непонятно, что будет, если
функцию объявить как overload, но не написать никаких альтернатив. Что это - ошибка?
А если две такие функции находятся в раздельно компилируемых модулях? В общем, во второй
версии языка слово overload было отменено.

Никакой магии тут нет, если представить себе, что компилятор делает то же самое, что делали
программисты на Fortran. Фактически при компиляции перегруженных функций создаются "внутренние"
имена для них, и в эти имена включаются типы параметров. Например, перечисленные выше функции
могут быть названы print@int, print@char и print@int@char. Если такие имена создаются для всех
компилируемых функций, то слово overload оказывается не нужным. Здесь используется та особенность,
что символ @ может появляться во внутренних именах функций, с которыми работает линкер, но запрещен
в именах C++.

Компилятор может различать полиморфные функции по типу параметров, но не по типу результата.

### Шаблоны (generics)

Альтернативой полиморфным функциям является концепция универсальных «шаблонных» функций.
Рассмотрим ее на примерах из языков C++ и Ada.

~~~c++
template< typename T > void TSwap( T& a, T& b )
{
   T c;
   c = a;
   a = b;
   b = c;
}

int main()
{
   int a,b; float c,d;
...
   TSwap<int>(a,b);   // меняем местами целочисленные переменные
   TSwap<float>(c,d); // меняем местами вещественные переменные
}
~~~

Ada:

~~~ada
generic
  type Element_T is private;  --  Element_T это параметр
procedure Swap (X, Y : in out Element_T);

procedure Swap (X, Y : in out Element_T) is
  Temporary : constant Element_T := X;
begin
  X := Y;
  Y := Temporary;
end Swap;

procedure Swap_Integers is new Swap (Integer); -- создаем процедуру для целых
procedure Swap_Chars is new Swap (Character); -- для символов

-- Используем функцию
a,b : integer; c,d: character;
Swap_Integers(a,b);
Swap_Chars(c,d);
~~~

В обоих случаях описывается шаблон - некая общая форма для работы с данными любого
типа (или какого-то набора типов). У шаблона присутствует параметр - тип данных, с
которым надо работать. При компиляции программы вместо формального типа подставляется
фактический и создается новая функция. В языке C++ ее имя состоит из имени шаблона к
которому приписано имя типа в угловых скобках; в языке Ada имя каждой функции нужно
придумывать отдельно. Каждый такой шаблон эквивалентен целому «семейству» полиморфных
функций. Разница между полиморфными функциями и шаблонами состоит в том, полиморфные
функции для разных типов могут быть существенно различными, тогда как шаблоны внешне
имеют один и тот же код для каждого типа, хотя полученный в результате компиляции
машинный код может существенно различаться.

### Замыкания

Нравится нам это или нет, но многие функции используют какой-то внешний контекст. Это
могут быть глобальные переменные, константы, другие функции. В тех языках, где функции
могут быть объектами первого класса, их можно возвращать из других функций в качестве
результата и передавать как параметры. Вот как это происходит в языке JavaScript:

~~~javascript
function differential (f, dx) {
  return function (x) {
    return (f(x + dx) - f(x)) / dx;
  };
}
~~~

Функция  differential возвращает функцию для вычисления отношения заданных малых
приращений другой функции к приращению аргумента. Чем это отличается от указателя на функцию?
Очень просто: в случае указателя функция должна уже где-то существовать, в случае функции
как значения она создается в процессе выполнения программы. Как именно это происходит -
отдельный вопрос.

Заметим, что переменная dx, переданная в функцию differential, «замораживается» в возвращаемой
безымянной функции. Следующий вызов  differential породит другую  безымянную функцию, с
«вмороженным» в нее другим значением dx. Это еще один пример так называемого контекста, то
есть всех сущностей, от которых зависит значение, возвращаемое функцией.

Функция вместе с контекстом в ряде языков представляет собой объект первого класса и
носит название замыкания.

Возвращать как значение функцию, не имеющую контекста, технологически намного проще, чем
замыкание, но в языке Ada, где такие функции выделены в отдельный класс, они не являются
объектами первого класса. Замыкания впервые появились в функциональных языках, потом в языках, задуманных
как интерпретируемые, и только в конце первого десятилетия 21 века начали появляться в
традиционных языках, таких как C и Pascal.

Пример на Delphi

~~~pascal
type
  TCounter = reference to function: integer;

function MakeCounter: TCounter;
var
  i: integer;
begin
  i := 0;
  result := function: integer
            begin
              inc(i);
              result := i;
            end;
end;
~~~

### Генераторы

Одно из наиболее распространенных применений функций с внешним контекстом это создание
генераторов, то есть функций, возвращающих каждый раз новое значение. Это может быть
порядковый номер, псевдослучайное число или что-то еще. В любом случае функция
должна как-то запомнить свое состояние и восстановить его при следующем вызове. Если при
этом требуется какая-то инициализация, то необходима еще одна функция.

Рассмотрим пример

~~~c
int number;

void init_number(int startvalue)
{
  number = startvalue;
}

int get_next_number()
{
  return number++;
}
~~~

Таким образом, для простой задачи нам нужны сразу три объекта, причем если генераторов нужно
несколько, то задача дополнительно усложняется. Объектно-ориентированное программирование предлагает
решение проблемы, состоящее в том, что все три компонента генератора «упаковываются» в целостный объект.
Так гораздо удобнее, но проблема трех сущностей никуда не девается. Вот как решается эта задача в языке
JavaScript, причем без явного объявления объектов:

~~~javascript
function next_number(startvalue)
{
 var  number =  startvalue;
 while (true)
 {
    yield  number++;
 }
}

v=next_number(10);
a = v.next();  //  a=10
b = v.next();  //  b=11
~~~

Оператор yield возвращает специальный вид замыкания - генератор. К этому генератору можно обратиться
посредством вызова next() чтобы получить очередное значение. Оператор yield можно рассматривать как
разновидность оператора return. Он как бы останавливает вычисление функции и возвращает нечто, по сути
своей похожее на замыкание. Вызов next() продолжает выполнение и возвращает очередное вычисленное значение.
В языке Python генераторы выглядят более прозрачно:

~~~python
# объявление функции
def countfrom(n):
    while True:
        yield n
        n += 1

# Использование

for i in countfrom(10):
     print(i)
~~~

На самом деле функция countfrom возвращает объект, но это совершенно не заметно.

То же самое в языке nim:

~~~nim
iterator countup(a, b: int): int =
  var res = a
  while res <= b:
    yield res
    inc(res)
~~~
